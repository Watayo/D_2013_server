# node-wasm

**An experimental WebAssembly loader for Node.js**

## Usage

Load a `.wasm` file as a stringified JavaScript function:

```js
var wasm = require('wasm')

var fnStr = wasm('/path/to/mod.wasm')
```

Alternatively, use the Node module system to load executable functions:

```js
require('wasm/require') // requiring .wasm files now works

var fn = require('/path/to/mod.wasm')
```

## Wat?

### WebAssembly? Eh?

[WebAssembly](https://github.com/WebAssembly/design/blob/master/HighLevelGoals.md) can be thought of as a step further than asm.js toward making an optimal compile-to target for the web. [Emscripten](http://kripken.github.io/emscripten-site/) does a nice job of encoding C++ code to asm.js but the resulting code is bloated and parse-time heavy. WebAssembly is intended to be compact and quick to load. Eventually WebAssembly is likely to make it possible to run all kinds of code in the browser without the need to compile directly to JavaScript.

### Wow, what can I do with this?

Hold up there cowboy! You can't do much with this yet so don't get too excited.

This project is experimental for now and piggy-backs off the [WebAssembly Polyfill prototype](https://github.com/WebAssembly/polyfill-prototype-1) for the browser which compiles asm.js files to the current experimental WebAssembly binary format, which is far from standardised. So for now, this project is an exploration in what might be possible by combining WebAssembly and Node.js.

### Does this need to be a native add-on?

Technically no, the current polyfill uses Emscripten to put the `.wasm` decoder into the browser so we could do the same with Node.

However, the simplest path for getting this running and allowing experimentation is to connect a decoder directly to Node via a native add-on. Perhaps in the future it will make more sense to distribute this as pure JavaScript.

### Why bother putting this in Node.js?

WebAssembly on the server has the potential to be even more useful and interesting in the browser, depending on what you're trying to achieve. An efficient compile-to target with a single runtime could do for the server what the JVM attempted to do, _except_ without the bloat and with the runtime model of Node.js.

## Example

_Found in the examples subdirectory._


Given an asm.js-compatible Fibonacci number calculator:

```js
function fib(stdlib, foreign, heap) {
  "use asm";

  function fib(n) {
    n = n|0;
    var f1=0;
    var f2=0;
    if (n >>> 0 < 3) {
      return 1|0;
    }
    f1=fib(n-1)|0;
    f2=fib(n-2)|0;
    return f1 + f2;
  }
 
  return fib;
}
```

Compiled to `.wasm.` using the [WebAssembly Polyfill prototype](https://github.com/WebAssembly/polyfill-prototype-1) asm.js packer:

```
$ pack-asmjs fib.js fib.wasm
```

Gives us a 54 byte file:

```
7761 736d 3903 0000 0000 0001 0001 0000
0000 0000 0000 0001 0000 8204 1135 c0a3
1001 0fa1 8116 001f c0a1 8216 001f c0a2
0f1e c1c2 0000
```

Now we can execute it, passing `global` in place of the asm.js `stdlib` argument:

```
$ node -pe 'require("../require"); require("./fib.wasm")(global)(35)'
9227465
```

## Authors and Contributors

<table><tbody>
<tr><th align="left">Rod Vagg</th><td><a href="https://github.com/rvagg">GitHub/rvagg</a></td><td><a href="http://twitter.com/rvagg">Twitter/@rvagg</a></td></tr>
</tbody></table>

Contributions are welcomed from experimenters wanting to join the fun!

## License & Copyright

**node-wasm** is Copyright (c) 2015 NodeSource and licensed under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE.md file for more details.
